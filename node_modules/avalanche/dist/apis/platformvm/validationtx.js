"use strict";
/**
 * @packageDocumentation
 * @module API-PlatformVM-ValidationTx
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddValidatorTx = exports.AddDelegatorTx = exports.WeightedValidatorTx = exports.ValidatorTx = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const basetx_1 = require("./basetx");
const outputs_1 = require("../platformvm/outputs");
const buffer_1 = require("buffer/");
const constants_1 = require("./constants");
const constants_2 = require("../../utils/constants");
const helperfunctions_1 = require("../../utils/helperfunctions");
const outputs_2 = require("./outputs");
const serialization_1 = require("../../utils/serialization");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
const serializer = serialization_1.Serialization.getInstance();
/**
 * Abstract class representing an transactions with validation information.
 */
class ValidatorTx extends basetx_1.BaseTx {
    constructor(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime) {
        super(networkid, blockchainid, outs, ins, memo);
        this._typeName = "ValidatorTx";
        this._typeID = undefined;
        this.nodeID = buffer_1.Buffer.alloc(20);
        this.startTime = buffer_1.Buffer.alloc(8);
        this.endTime = buffer_1.Buffer.alloc(8);
        this.nodeID = nodeID;
        this.startTime = bintools.fromBNToBuffer(startTime, 8);
        this.endTime = bintools.fromBNToBuffer(endTime, 8);
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "nodeID": serializer.encoder(this.nodeID, encoding, "Buffer", "nodeID"), "startTime": serializer.encoder(this.startTime, encoding, "Buffer", "decimalString"), "endTime": serializer.encoder(this.endTime, encoding, "Buffer", "decimalString") });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.nodeID = serializer.decoder(fields["nodeID"], encoding, "nodeID", "Buffer", 20);
        this.startTime = serializer.decoder(fields["startTime"], encoding, "decimalString", "Buffer", 8);
        this.endTime = serializer.decoder(fields["endTime"], encoding, "decimalString", "Buffer", 8);
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the stake amount.
     */
    getNodeID() {
        return this.nodeID;
    }
    /**
     * Returns a string for the nodeID amount.
     */
    getNodeIDString() {
        return helperfunctions_1.bufferToNodeIDString(this.nodeID);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getStartTime() {
        return bintools.fromBufferToBN(this.startTime);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getEndTime() {
        return bintools.fromBufferToBN(this.endTime);
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        this.nodeID = bintools.copyFrom(bytes, offset, offset + 20);
        offset += 20;
        this.startTime = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        this.endTime = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[ValidatorTx]].
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        const bsize = superbuff.length + this.nodeID.length + this.startTime.length + this.endTime.length;
        return buffer_1.Buffer.concat([
            superbuff,
            this.nodeID,
            this.startTime,
            this.endTime
        ], bsize);
    }
}
exports.ValidatorTx = ValidatorTx;
class WeightedValidatorTx extends ValidatorTx {
    /**
     * Class representing an unsigned AddSubnetValidatorTx transaction.
     *
     * @param networkid Optional. Networkid, [[DefaultNetworkID]]
     * @param blockchainid Optional. Blockchainid, default Buffer.alloc(32, 16)
     * @param outs Optional. Array of the [[TransferableOutput]]s
     * @param ins Optional. Array of the [[TransferableInput]]s
     * @param memo Optional. {@link https://github.com/feross/buffer|Buffer} for the memo field
     * @param nodeID Optional. The node ID of the validator being added.
     * @param startTime Optional. The Unix time when the validator starts validating the Primary Network.
     * @param endTime Optional. The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
     * @param weight Optional. The amount of nAVAX the validator is staking.
     */
    constructor(networkid = constants_2.DefaultNetworkID, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, nodeID = undefined, startTime = undefined, endTime = undefined, weight = undefined) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime);
        this._typeName = "WeightedValidatorTx";
        this._typeID = undefined;
        this.weight = buffer_1.Buffer.alloc(8);
        if (typeof weight !== undefined) {
            this.weight = bintools.fromBNToBuffer(weight, 8);
        }
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "weight": serializer.encoder(this.weight, encoding, "Buffer", "decimalString") });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.weight = serializer.decoder(fields["weight"], encoding, "decimalString", "Buffer", 8);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getWeight() {
        return bintools.fromBufferToBN(this.weight);
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the stake amount.
     */
    getWeightBuffer() {
        return this.weight;
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        this.weight = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[AddSubnetValidatorTx]].
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        return buffer_1.Buffer.concat([superbuff, this.weight]);
    }
}
exports.WeightedValidatorTx = WeightedValidatorTx;
/* Must implement later, the signing process isn't friendly to AvalancheJS

export class AddSubnetValidatorTx extends WeightedValidatorTx {
    protected subnetID:Buffer = Buffer.alloc(32);
    protected subnetAddrs:Array<Buffer> = [];
    protected subnetAuthIdxs:Array<Buffer> = [];


    getTxType = ():number => {
        return PlatformVMConstants.ADDSUBNETVALIDATORTX;
    }


    getSubnetID = ():Buffer => {
        return this.subnetID;
    }


    getSubnetIDString = ():string => {
        return bintools.cb58Encode(this.subnetID);
    }


    getSubnetAuthAddresses = ():Array<Buffer> => {
        return this.subnetAddrs;
    }


    setSubnetAuthAddresses = (addrs:Array<Buffer>):void => {
        this.subnetAddrs = addrs;
    }

    calcSubnetAuthIdxs = (addrs:Array<Buffer>):Array<Buffer> => {
        let idxs:Array<Buffer> = [];
        addrs = addrs.sort();
        for(let i = 0; i < addrs.length; i++){
            let idx:Buffer = Buffer.alloc(4);
            idx.writeUInt32BE(i,0);
            idxs.push(idx);
        }
    }


    getSubnetAuthIdxs = ():Array<Buffer> => {
        return this.subnetAddrs;
    }

    fromBuffer(bytes:Buffer, offset:number = 0):number {
        offset = super.fromBuffer(bytes, offset);
        this.subnetID = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        let sublenbuff:Buffer = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        let sublen:number = sublenbuff.readUInt32BE(0);
        for(let i = 0; i < sublen; i++){

        }
        offset = this.subnetAuth.fromBuffer(bytes, offset);
        return offset;
    }


    toBuffer():Buffer {
        const superbuff:Buffer = super.toBuffer();

        return Buffer.concat([superbuff, this.subnetID, subAuth], superbuff.length + this.subnetID.length + subAuth.length);
    }


    sign(msg:Buffer, kc:KeyChain):Array<Credential> {
        let creds:Array<SECPCredential> = super.sign(msg, kc);
        const cred:SECPCredential = SelectCredentialClass(PlatformVMConstants.SECPCREDENTIAL) as SECPCredential;
        for(let i = 0; i  < this.subnetAuth.length ; i++) {
            if(!kc.hasKey(this.subnetAuth[i])) {
                throw new Error("AddSubnetValidatorTx.sign -- specified address in subnetAuth not existent in provided keychain.");
            }
            
            let kp:KeyPair = kc.getKey(this.subnetAuth[i]);
            const signval:Buffer = kp.sign(msg);
            const sig:Signature = new Signature();
            sig.fromBuffer(signval);
            cred.addSignature(sig);
        }
        creds.push(cred);
        return creds;
    }


    constructor(
        networkid:number = DefaultNetworkID,
        blockchainid:Buffer = Buffer.alloc(32, 16),
        outs:Array<TransferableOutput> = undefined,
        ins:Array<TransferableInput> = undefined,
        memo:Buffer = undefined,
        nodeID:Buffer = undefined,
        startTime:BN = undefined,
        endTime:BN = undefined,
        weight:BN = undefined,
        subnetID:Buffer = undefined,
        subnetAuth:Array<Buffer> = undefined
    ) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime, weight);
        if(typeof subnetID !== undefined){
            this.subnetID = subnetID;
        }
        if(typeof subnetAuth !== undefined) {
            this.subnetAuth = subnetAuth;
        }
    }

}
*/
/**
 * Class representing an unsigned AddDelegatorTx transaction.
 */
class AddDelegatorTx extends WeightedValidatorTx {
    /**
     * Class representing an unsigned AddDelegatorTx transaction.
     *
     * @param networkid Optional. Networkid, [[DefaultNetworkID]]
     * @param blockchainid Optional. Blockchainid, default Buffer.alloc(32, 16)
     * @param outs Optional. Array of the [[TransferableOutput]]s
     * @param ins Optional. Array of the [[TransferableInput]]s
     * @param memo Optional. {@link https://github.com/feross/buffer|Buffer} for the memo field
     * @param nodeID Optional. The node ID of the validator being added.
     * @param startTime Optional. The Unix time when the validator starts validating the Primary Network.
     * @param endTime Optional. The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
     * @param stakeAmount Optional. The amount of nAVAX the validator is staking.
     * @param stakeOuts Optional. The outputs used in paying the stake.
     * @param rewardOwners Optional. The [[ParseableOutput]] containing a [[SECPOwnerOutput]] for the rewards.
     */
    constructor(networkid = constants_2.DefaultNetworkID, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, nodeID = undefined, startTime = undefined, endTime = undefined, stakeAmount = undefined, stakeOuts = undefined, rewardOwners = undefined) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime, stakeAmount);
        this._typeName = "AddDelegatorTx";
        this._typeID = constants_1.PlatformVMConstants.ADDDELEGATORTX;
        this.stakeOuts = [];
        this.rewardOwners = undefined;
        /**
           * Returns the id of the [[AddDelegatorTx]]
           */
        this.getTxType = () => {
            return this._typeID;
        };
        if (typeof stakeOuts !== undefined) {
            this.stakeOuts = stakeOuts;
        }
        this.rewardOwners = rewardOwners;
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "stakeOuts": this.stakeOuts.map((s) => s.serialize(encoding)), "rewardOwners": this.rewardOwners.serialize(encoding) });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.stakeOuts = fields["stakeOuts"].map((s) => {
            let xferout = new outputs_1.TransferableOutput();
            xferout.deserialize(s, encoding);
            return xferout;
        });
        this.rewardOwners = new outputs_2.ParseableOutput();
        this.rewardOwners.deserialize(fields["rewardOwners"], encoding);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getStakeAmount() {
        return this.getWeight();
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the stake amount.
     */
    getStakeAmountBuffer() {
        return this.weight;
    }
    /**
     * Returns the array of outputs being staked.
     */
    getStakeOuts() {
        return this.stakeOuts;
    }
    /**
     * Should match stakeAmount. Used in sanity checking.
     */
    getStakeOutsTotal() {
        let val = new bn_js_1.default(0);
        for (let i = 0; i < this.stakeOuts.length; i++) {
            val = val.add(this.stakeOuts[i].getOutput().getAmount());
        }
        return val;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the reward address.
     */
    getRewardOwners() {
        return this.rewardOwners;
    }
    getTotalOuts() {
        return [...this.getOuts(), ...this.getStakeOuts()];
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        const numstakeouts = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const outcount = numstakeouts.readUInt32BE(0);
        this.outs = [];
        for (let i = 0; i < outcount; i++) {
            const xferout = new outputs_1.TransferableOutput();
            offset = xferout.fromBuffer(bytes, offset);
            this.outs.push(xferout);
        }
        this.rewardOwners = new outputs_2.ParseableOutput();
        offset = this.rewardOwners.fromBuffer(bytes, offset);
        offset += constants_1.PlatformVMConstants.ADDRESSLENGTH;
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[AddDelegatorTx]].
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        let bsize = superbuff.length;
        const numouts = buffer_1.Buffer.alloc(4);
        numouts.writeUInt32BE(this.stakeOuts.length, 0);
        let barr = [super.toBuffer(), numouts];
        bsize += numouts.length;
        this.stakeOuts = this.stakeOuts.sort(outputs_1.TransferableOutput.comparator());
        for (let i = 0; i < this.stakeOuts.length; i++) {
            let out = this.stakeOuts[i].toBuffer();
            barr.push(out);
            bsize += out.length;
        }
        let ro = this.rewardOwners.toBuffer();
        barr.push(ro);
        bsize += ro.length;
        return buffer_1.Buffer.concat(barr, bsize);
    }
    clone() {
        let newbase = new AddDelegatorTx();
        newbase.fromBuffer(this.toBuffer());
        return newbase;
    }
    create(...args) {
        return new AddDelegatorTx(...args);
    }
}
exports.AddDelegatorTx = AddDelegatorTx;
class AddValidatorTx extends AddDelegatorTx {
    /**
     * Class representing an unsigned AddValidatorTx transaction.
     *
     * @param networkid Optional. Networkid, [[DefaultNetworkID]]
     * @param blockchainid Optional. Blockchainid, default Buffer.alloc(32, 16)
     * @param outs Optional. Array of the [[TransferableOutput]]s
     * @param ins Optional. Array of the [[TransferableInput]]s
     * @param memo Optional. {@link https://github.com/feross/buffer|Buffer} for the memo field
     * @param nodeID Optional. The node ID of the validator being added.
     * @param startTime Optional. The Unix time when the validator starts validating the Primary Network.
     * @param endTime Optional. The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
     * @param stakeAmount Optional. The amount of nAVAX the validator is staking.
     * @param stakeOuts Optional. The outputs used in paying the stake.
     * @param rewardOwners Optional. The [[ParseableOutput]] containing the [[SECPOwnerOutput]] for the rewards.
     * @param delegationFee Optional. The percent fee this validator charges when others delegate stake to them.
     * Up to 4 decimal places allowed; additional decimal places are ignored. Must be between 0 and 100, inclusive.
     * For example, if delegationFeeRate is 1.2345 and someone delegates to this validator, then when the delegation
     * period is over, 1.2345% of the reward goes to the validator and the rest goes to the delegator.
     */
    constructor(networkid = constants_2.DefaultNetworkID, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, nodeID = undefined, startTime = undefined, endTime = undefined, stakeAmount = undefined, stakeOuts = undefined, rewardOwners = undefined, delegationFee = undefined) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, stakeOuts, rewardOwners);
        this._typeName = "AddValidatorTx";
        this._typeID = constants_1.PlatformVMConstants.ADDVALIDATORTX;
        this.delegationFee = 0;
        /**
           * Returns the id of the [[AddValidatorTx]]
           */
        this.getTxType = () => {
            return this._typeID;
        };
        if (typeof delegationFee === "number") {
            if (delegationFee >= 0 && delegationFee <= 100) {
                this.delegationFee = parseFloat(delegationFee.toFixed(4));
            }
            else {
                throw new Error("AddValidatorTx.constructor -- delegationFee must be in the range of 0 and 100, inclusively.");
            }
        }
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "delegationFee": serializer.encoder(this.getDelegationFeeBuffer(), encoding, "Buffer", "decimalString", 4) });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        let dbuff = serializer.decoder(fields["delegationFee"], encoding, "decimalString", "Buffer", 4);
        this.delegationFee = dbuff.readUInt32BE(0) / AddValidatorTx.delegatorMultiplier;
    }
    /**
     * Returns the delegation fee (represents a percentage from 0 to 100);
     */
    getDelegationFee() {
        return this.delegationFee;
    }
    /**
     * Returns the binary representation of the delegation fee as a {@link https://github.com/feross/buffer|Buffer}.
     */
    getDelegationFeeBuffer() {
        let dBuff = buffer_1.Buffer.alloc(4);
        let buffnum = parseFloat(this.delegationFee.toFixed(4)) * AddValidatorTx.delegatorMultiplier;
        dBuff.writeUInt32BE(buffnum, 0);
        return dBuff;
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        let dbuff = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.delegationFee = dbuff.readUInt32BE(0) / AddValidatorTx.delegatorMultiplier;
        return offset;
    }
    toBuffer() {
        let superBuff = super.toBuffer();
        let feeBuff = this.getDelegationFeeBuffer();
        return buffer_1.Buffer.concat([superBuff, feeBuff]);
    }
}
exports.AddValidatorTx = AddValidatorTx;
AddValidatorTx.delegatorMultiplier = 10000;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbnR4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvcGxhdGZvcm12bS92YWxpZGF0aW9udHgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7O0FBRUgsa0RBQXVCO0FBQ3ZCLG9FQUE0QztBQUM1QyxxQ0FBa0M7QUFDbEMsbURBQTJEO0FBRTNELG9DQUFpQztBQUNqQywyQ0FBa0Q7QUFDbEQscURBQXlEO0FBQ3pELGlFQUFtRTtBQUNuRSx1Q0FBMEQ7QUFDMUQsNkRBQThFO0FBRTlFOztHQUVHO0FBQ0gsTUFBTSxRQUFRLEdBQUcsa0JBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUN4QyxNQUFNLFVBQVUsR0FBRyw2QkFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRS9DOztHQUVHO0FBQ0gsTUFBc0IsV0FBWSxTQUFRLGVBQU07SUE0RTVDLFlBQ0ksU0FBZ0IsRUFDaEIsWUFBbUIsRUFDbkIsSUFBOEIsRUFDOUIsR0FBNEIsRUFDNUIsSUFBWSxFQUNaLE1BQWMsRUFDZCxTQUFhLEVBQ2IsT0FBVztRQUVYLEtBQUssQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFyRjFDLGNBQVMsR0FBRyxhQUFhLENBQUM7UUFDMUIsWUFBTyxHQUFHLFNBQVMsQ0FBQztRQWtCcEIsV0FBTSxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakMsY0FBUyxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkMsWUFBTyxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFpRXZDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxD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LHdDQWtIQztBQTlGa0Isa0NBQW1CLEdBQVUsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVBJLVBsYXRmb3JtVk0tVmFsaWRhdGlvblR4XG4gKi9cblxuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBCaW5Ub29scyBmcm9tICcuLi8uLi91dGlscy9iaW50b29scyc7XG5pbXBvcnQgeyBCYXNlVHggfSBmcm9tICcuL2Jhc2V0eCc7XG5pbXBvcnQgeyBUcmFuc2ZlcmFibGVPdXRwdXQgfSBmcm9tICcuLi9wbGF0Zm9ybXZtL291dHB1dHMnO1xuaW1wb3J0IHsgVHJhbnNmZXJhYmxlSW5wdXQgfSBmcm9tICcuLi9wbGF0Zm9ybXZtL2lucHV0cyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXIvJztcbmltcG9ydCB7IFBsYXRmb3JtVk1Db25zdGFudHMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBEZWZhdWx0TmV0d29ya0lEIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGJ1ZmZlclRvTm9kZUlEU3RyaW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvaGVscGVyZnVuY3Rpb25zJztcbmltcG9ydCB7IEFtb3VudE91dHB1dCwgUGFyc2VhYmxlT3V0cHV0IH0gZnJvbSAnLi9vdXRwdXRzJztcbmltcG9ydCB7IFNlcmlhbGl6YXRpb24sIFNlcmlhbGl6ZWRFbmNvZGluZyB9IGZyb20gJy4uLy4uL3V0aWxzL3NlcmlhbGl6YXRpb24nO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuY29uc3Qgc2VyaWFsaXplciA9IFNlcmlhbGl6YXRpb24uZ2V0SW5zdGFuY2UoKTtcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyByZXByZXNlbnRpbmcgYW4gdHJhbnNhY3Rpb25zIHdpdGggdmFsaWRhdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZhbGlkYXRvclR4IGV4dGVuZHMgQmFzZVR4IHtcbiAgICBwcm90ZWN0ZWQgX3R5cGVOYW1lID0gXCJWYWxpZGF0b3JUeFwiO1xuICAgIHByb3RlY3RlZCBfdHlwZUlEID0gdW5kZWZpbmVkO1xuXG4gICAgc2VyaWFsaXplKGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpOm9iamVjdCB7XG4gICAgICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIFwibm9kZUlEXCI6c2VyaWFsaXplci5lbmNvZGVyKHRoaXMubm9kZUlELCBlbmNvZGluZywgXCJCdWZmZXJcIiwgXCJub2RlSURcIiksXG4gICAgICAgICAgICBcInN0YXJ0VGltZVwiOnNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLnN0YXJ0VGltZSwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiZGVjaW1hbFN0cmluZ1wiKSxcbiAgICAgICAgICAgIFwiZW5kVGltZVwiOnNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLmVuZFRpbWUsIGVuY29kaW5nLCBcIkJ1ZmZlclwiLCBcImRlY2ltYWxTdHJpbmdcIilcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVzZXJpYWxpemUoZmllbGRzOm9iamVjdCwgZW5jb2Rpbmc6U2VyaWFsaXplZEVuY29kaW5nID0gXCJoZXhcIikge1xuICAgICAgICBzdXBlci5kZXNlcmlhbGl6ZShmaWVsZHMsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5ub2RlSUQgPSBzZXJpYWxpemVyLmRlY29kZXIoZmllbGRzW1wibm9kZUlEXCJdLCBlbmNvZGluZywgXCJub2RlSURcIiwgXCJCdWZmZXJcIiwgMjApO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJzdGFydFRpbWVcIl0sIGVuY29kaW5nLCBcImRlY2ltYWxTdHJpbmdcIiwgXCJCdWZmZXJcIiwgOCk7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJlbmRUaW1lXCJdLCBlbmNvZGluZywgXCJkZWNpbWFsU3RyaW5nXCIsIFwiQnVmZmVyXCIsIDgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBub2RlSUQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDIwKTtcbiAgICBwcm90ZWN0ZWQgc3RhcnRUaW1lOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICBwcm90ZWN0ZWQgZW5kVGltZTpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoOCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBzdGFrZSBhbW91bnQuXG4gICAgICovXG4gICAgZ2V0Tm9kZUlEKCk6QnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUlEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgZm9yIHRoZSBub2RlSUQgYW1vdW50LlxuICAgICAqL1xuICAgIGdldE5vZGVJRFN0cmluZygpOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBidWZmZXJUb05vZGVJRFN0cmluZyh0aGlzLm5vZGVJRCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBmb3IgdGhlIHN0YWtlIGFtb3VudC5cbiAgICAgKi9cbiAgICBnZXRTdGFydFRpbWUoKXtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMuc3RhcnRUaW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gZm9yIHRoZSBzdGFrZSBhbW91bnQuXG4gICAgICovXG4gICAgZ2V0RW5kVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMuZW5kVGltZSk7XG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLm5vZGVJRCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDIwKTtcbiAgICAgICAgb2Zmc2V0ICs9IDIwO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDgpO1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgOCk7XG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tWYWxpZGF0b3JUeF1dLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgY29uc3Qgc3VwZXJidWZmOkJ1ZmZlciA9IHN1cGVyLnRvQnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGJzaXplOm51bWJlciA9IHN1cGVyYnVmZi5sZW5ndGggKyB0aGlzLm5vZGVJRC5sZW5ndGggKyB0aGlzLnN0YXJ0VGltZS5sZW5ndGggKyB0aGlzLmVuZFRpbWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBzdXBlcmJ1ZmYsXG4gICAgICAgICAgICB0aGlzLm5vZGVJRCxcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lLFxuICAgICAgICAgICAgdGhpcy5lbmRUaW1lXG4gICAgICAgIF0sIGJzaXplKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG5ldHdvcmtpZDpudW1iZXIsIFxuICAgICAgICBibG9ja2NoYWluaWQ6QnVmZmVyLCBcbiAgICAgICAgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+LCBcbiAgICAgICAgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiwgXG4gICAgICAgIG1lbW8/OkJ1ZmZlciwgXG4gICAgICAgIG5vZGVJRD86QnVmZmVyLCBcbiAgICAgICAgc3RhcnRUaW1lPzpCTiwgXG4gICAgICAgIGVuZFRpbWU/OkJOXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8pO1xuICAgICAgICB0aGlzLm5vZGVJRCA9IG5vZGVJRDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcihzdGFydFRpbWUsIDgpO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcihlbmRUaW1lLCA4KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFdlaWdodGVkVmFsaWRhdG9yVHggZXh0ZW5kcyBWYWxpZGF0b3JUeCB7XG4gICAgcHJvdGVjdGVkIF90eXBlTmFtZSA9IFwiV2VpZ2h0ZWRWYWxpZGF0b3JUeFwiO1xuICAgIHByb3RlY3RlZCBfdHlwZUlEID0gdW5kZWZpbmVkO1xuXG4gICAgc2VyaWFsaXplKGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpOm9iamVjdCB7XG4gICAgICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIFwid2VpZ2h0XCI6IHNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLndlaWdodCwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiZGVjaW1hbFN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXNlcmlhbGl6ZShmaWVsZHM6b2JqZWN0LCBlbmNvZGluZzpTZXJpYWxpemVkRW5jb2RpbmcgPSBcImhleFwiKSB7XG4gICAgICAgIHN1cGVyLmRlc2VyaWFsaXplKGZpZWxkcywgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndlaWdodCA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJ3ZWlnaHRcIl0sIGVuY29kaW5nLCBcImRlY2ltYWxTdHJpbmdcIiwgXCJCdWZmZXJcIiwgOCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHdlaWdodDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoOCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gZm9yIHRoZSBzdGFrZSBhbW91bnQuXG4gICAgICovXG4gICAgZ2V0V2VpZ2h0KCk6Qk4ge1xuICAgICAgICByZXR1cm4gYmludG9vbHMuZnJvbUJ1ZmZlclRvQk4odGhpcy53ZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIHN0YWtlIGFtb3VudC5cbiAgICAgKi9cbiAgICBnZXRXZWlnaHRCdWZmZXIoKTpCdWZmZXIge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQ7XG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLndlaWdodCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDgpO1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbQWRkU3VibmV0VmFsaWRhdG9yVHhdXS5cbiAgICAgKi9cbiAgICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgICAgIGNvbnN0IHN1cGVyYnVmZjpCdWZmZXIgPSBzdXBlci50b0J1ZmZlcigpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbc3VwZXJidWZmLCB0aGlzLndlaWdodF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBBZGRTdWJuZXRWYWxpZGF0b3JUeCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JraWQgT3B0aW9uYWwuIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIE9wdGlvbmFsLiBCbG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICogQHBhcmFtIGlucyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXNcbiAgICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbC4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIG5vZGVJRCBPcHRpb25hbC4gVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdGFydHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdG9wcyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsgKGFuZCBzdGFrZWQgQVZBWCBpcyByZXR1cm5lZCkuXG4gICAgICogQHBhcmFtIHdlaWdodCBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBuQVZBWCB0aGUgdmFsaWRhdG9yIGlzIHN0YWtpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG5ldHdvcmtpZDpudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELCBcbiAgICAgICAgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLCBcbiAgICAgICAgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkLCBcbiAgICAgICAgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBcbiAgICAgICAgbm9kZUlEOkJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICAgIHN0YXJ0VGltZTpCTiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIGVuZFRpbWU6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHdlaWdodDpCTiA9IHVuZGVmaW5lZCxcbiAgICApIHtcbiAgICAgICAgc3VwZXIobmV0d29ya2lkLCBibG9ja2NoYWluaWQsIG91dHMsIGlucywgbWVtbywgbm9kZUlELCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgICBpZih0eXBlb2Ygd2VpZ2h0ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy53ZWlnaHQgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcih3ZWlnaHQsIDgpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4vKiBNdXN0IGltcGxlbWVudCBsYXRlciwgdGhlIHNpZ25pbmcgcHJvY2VzcyBpc24ndCBmcmllbmRseSB0byBBdmFsYW5jaGVKU1xuXG5leHBvcnQgY2xhc3MgQWRkU3VibmV0VmFsaWRhdG9yVHggZXh0ZW5kcyBXZWlnaHRlZFZhbGlkYXRvclR4IHtcbiAgICBwcm90ZWN0ZWQgc3VibmV0SUQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBwcm90ZWN0ZWQgc3VibmV0QWRkcnM6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgIHByb3RlY3RlZCBzdWJuZXRBdXRoSWR4czpBcnJheTxCdWZmZXI+ID0gW107XG5cblxuICAgIGdldFR4VHlwZSA9ICgpOm51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBQbGF0Zm9ybVZNQ29uc3RhbnRzLkFERFNVQk5FVFZBTElEQVRPUlRYO1xuICAgIH1cblxuXG4gICAgZ2V0U3VibmV0SUQgPSAoKTpCdWZmZXIgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJuZXRJRDtcbiAgICB9XG5cblxuICAgIGdldFN1Ym5ldElEU3RyaW5nID0gKCk6c3RyaW5nID0+IHtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmNiNThFbmNvZGUodGhpcy5zdWJuZXRJRCk7XG4gICAgfVxuXG5cbiAgICBnZXRTdWJuZXRBdXRoQWRkcmVzc2VzID0gKCk6QXJyYXk8QnVmZmVyPiA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Ym5ldEFkZHJzO1xuICAgIH1cblxuXG4gICAgc2V0U3VibmV0QXV0aEFkZHJlc3NlcyA9IChhZGRyczpBcnJheTxCdWZmZXI+KTp2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zdWJuZXRBZGRycyA9IGFkZHJzO1xuICAgIH1cblxuICAgIGNhbGNTdWJuZXRBdXRoSWR4cyA9IChhZGRyczpBcnJheTxCdWZmZXI+KTpBcnJheTxCdWZmZXI+ID0+IHtcbiAgICAgICAgbGV0IGlkeHM6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgICAgICBhZGRycyA9IGFkZHJzLnNvcnQoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFkZHJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBpZHg6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgICAgaWR4LndyaXRlVUludDMyQkUoaSwwKTtcbiAgICAgICAgICAgIGlkeHMucHVzaChpZHgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBnZXRTdWJuZXRBdXRoSWR4cyA9ICgpOkFycmF5PEJ1ZmZlcj4gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJuZXRBZGRycztcbiAgICB9XG5cbiAgICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgICAgIG9mZnNldCA9IHN1cGVyLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuc3VibmV0SUQgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyAzMik7XG4gICAgICAgIG9mZnNldCArPSAzMjtcbiAgICAgICAgbGV0IHN1YmxlbmJ1ZmY6QnVmZmVyID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBsZXQgc3VibGVuOm51bWJlciA9IHN1YmxlbmJ1ZmYucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3VibGVuOyBpKyspe1xuXG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5zdWJuZXRBdXRoLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG5cbiAgICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgICAgIGNvbnN0IHN1cGVyYnVmZjpCdWZmZXIgPSBzdXBlci50b0J1ZmZlcigpO1xuXG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtzdXBlcmJ1ZmYsIHRoaXMuc3VibmV0SUQsIHN1YkF1dGhdLCBzdXBlcmJ1ZmYubGVuZ3RoICsgdGhpcy5zdWJuZXRJRC5sZW5ndGggKyBzdWJBdXRoLmxlbmd0aCk7XG4gICAgfVxuXG5cbiAgICBzaWduKG1zZzpCdWZmZXIsIGtjOktleUNoYWluKTpBcnJheTxDcmVkZW50aWFsPiB7XG4gICAgICAgIGxldCBjcmVkczpBcnJheTxTRUNQQ3JlZGVudGlhbD4gPSBzdXBlci5zaWduKG1zZywga2MpO1xuICAgICAgICBjb25zdCBjcmVkOlNFQ1BDcmVkZW50aWFsID0gU2VsZWN0Q3JlZGVudGlhbENsYXNzKFBsYXRmb3JtVk1Db25zdGFudHMuU0VDUENSRURFTlRJQUwpIGFzIFNFQ1BDcmVkZW50aWFsO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpICA8IHRoaXMuc3VibmV0QXV0aC5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmKCFrYy5oYXNLZXkodGhpcy5zdWJuZXRBdXRoW2ldKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFkZFN1Ym5ldFZhbGlkYXRvclR4LnNpZ24gLS0gc3BlY2lmaWVkIGFkZHJlc3MgaW4gc3VibmV0QXV0aCBub3QgZXhpc3RlbnQgaW4gcHJvdmlkZWQga2V5Y2hhaW4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQga3A6S2V5UGFpciA9IGtjLmdldEtleSh0aGlzLnN1Ym5ldEF1dGhbaV0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbnZhbDpCdWZmZXIgPSBrcC5zaWduKG1zZyk7XG4gICAgICAgICAgICBjb25zdCBzaWc6U2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZSgpO1xuICAgICAgICAgICAgc2lnLmZyb21CdWZmZXIoc2lnbnZhbCk7XG4gICAgICAgICAgICBjcmVkLmFkZFNpZ25hdHVyZShzaWcpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWRzLnB1c2goY3JlZCk7XG4gICAgICAgIHJldHVybiBjcmVkcztcbiAgICB9XG5cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBuZXR3b3JraWQ6bnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCwgXG4gICAgICAgIGJsb2NrY2hhaW5pZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDE2KSwgXG4gICAgICAgIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB1bmRlZmluZWQsIFxuICAgICAgICBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICAgIG5vZGVJRDpCdWZmZXIgPSB1bmRlZmluZWQsIFxuICAgICAgICBzdGFydFRpbWU6Qk4gPSB1bmRlZmluZWQsIFxuICAgICAgICBlbmRUaW1lOkJOID0gdW5kZWZpbmVkLFxuICAgICAgICB3ZWlnaHQ6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHN1Ym5ldElEOkJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3VibmV0QXV0aDpBcnJheTxCdWZmZXI+ID0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8sIG5vZGVJRCwgc3RhcnRUaW1lLCBlbmRUaW1lLCB3ZWlnaHQpO1xuICAgICAgICBpZih0eXBlb2Ygc3VibmV0SUQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnN1Ym5ldElEID0gc3VibmV0SUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIHN1Ym5ldEF1dGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdWJuZXRBdXRoID0gc3VibmV0QXV0aDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuKi9cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgQWRkRGVsZWdhdG9yVHggdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGREZWxlZ2F0b3JUeCBleHRlbmRzIFdlaWdodGVkVmFsaWRhdG9yVHgge1xuICAgIHByb3RlY3RlZCBfdHlwZU5hbWUgPSBcIkFkZERlbGVnYXRvclR4XCI7XG4gICAgcHJvdGVjdGVkIF90eXBlSUQgPSBQbGF0Zm9ybVZNQ29uc3RhbnRzLkFERERFTEVHQVRPUlRYO1xuXG4gICAgc2VyaWFsaXplKGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpOm9iamVjdCB7XG4gICAgICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuICB7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBcInN0YWtlT3V0c1wiOiB0aGlzLnN0YWtlT3V0cy5tYXAoKHMpID0+IHMuc2VyaWFsaXplKGVuY29kaW5nKSksXG4gICAgICAgICAgICBcInJld2FyZE93bmVyc1wiOiB0aGlzLnJld2FyZE93bmVycy5zZXJpYWxpemUoZW5jb2RpbmcpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlc2VyaWFsaXplKGZpZWxkczpvYmplY3QsIGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpIHtcbiAgICAgICAgc3VwZXIuZGVzZXJpYWxpemUoZmllbGRzLCBlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuc3Rha2VPdXRzID0gZmllbGRzW1wic3Rha2VPdXRzXCJdLm1hcCgoczpvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB4ZmVyb3V0OlRyYW5zZmVyYWJsZU91dHB1dCA9IG5ldyBUcmFuc2ZlcmFibGVPdXRwdXQoKTtcbiAgICAgICAgICAgIHhmZXJvdXQuZGVzZXJpYWxpemUocywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHhmZXJvdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJld2FyZE93bmVycyA9IG5ldyBQYXJzZWFibGVPdXRwdXQoKTtcbiAgICAgICAgdGhpcy5yZXdhcmRPd25lcnMuZGVzZXJpYWxpemUoZmllbGRzW1wicmV3YXJkT3duZXJzXCJdLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIFxuICAgIHByb3RlY3RlZCBzdGFrZU91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IFtdO1xuICAgIHByb3RlY3RlZCByZXdhcmRPd25lcnM6UGFyc2VhYmxlT3V0cHV0ID0gdW5kZWZpbmVkO1xuICBcbiAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBbW0FkZERlbGVnYXRvclR4XV1cbiAgICAgICAqL1xuICAgIGdldFR4VHlwZSA9ICgpOm51bWJlciA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZUlEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBmb3IgdGhlIHN0YWtlIGFtb3VudC5cbiAgICAgKi9cbiAgICBnZXRTdGFrZUFtb3VudCgpOkJOIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2VpZ2h0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgc3Rha2UgYW1vdW50LlxuICAgICAqL1xuICAgIGdldFN0YWtlQW1vdW50QnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIG91dHB1dHMgYmVpbmcgc3Rha2VkLlxuICAgICAqL1xuICAgIGdldFN0YWtlT3V0cygpOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFrZU91dHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIG1hdGNoIHN0YWtlQW1vdW50LiBVc2VkIGluIHNhbml0eSBjaGVja2luZy5cbiAgICAgKi9cbiAgICBnZXRTdGFrZU91dHNUb3RhbCgpOkJOIHtcbiAgICAgICAgbGV0IHZhbDpCTiA9IG5ldyBCTigwKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3Rha2VPdXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICB2YWwgPSB2YWwuYWRkKCh0aGlzLnN0YWtlT3V0c1tpXS5nZXRPdXRwdXQoKSBhcyBBbW91bnRPdXRwdXQpLmdldEFtb3VudCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSByZXdhcmQgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXRSZXdhcmRPd25lcnMoKTpQYXJzZWFibGVPdXRwdXQge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXdhcmRPd25lcnM7XG4gICAgfVxuICAgIFxuICAgIGdldFRvdGFsT3V0cygpOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4ge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuZ2V0T3V0cygpIGFzIEFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4sIC4uLnRoaXMuZ2V0U3Rha2VPdXRzKCldO1xuICAgIH1cblxuICAgIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICAgICAgb2Zmc2V0ID0gc3VwZXIuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbnVtc3Rha2VvdXRzID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBjb25zdCBvdXRjb3VudDpudW1iZXIgPSBudW1zdGFrZW91dHMucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICB0aGlzLm91dHMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG91dGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHhmZXJvdXQ6VHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dCgpO1xuICAgICAgICAgICAgb2Zmc2V0ID0geGZlcm91dC5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5vdXRzLnB1c2goeGZlcm91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXdhcmRPd25lcnMgPSBuZXcgUGFyc2VhYmxlT3V0cHV0KCk7XG4gICAgICAgIG9mZnNldCA9IHRoaXMucmV3YXJkT3duZXJzLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBQbGF0Zm9ybVZNQ29uc3RhbnRzLkFERFJFU1NMRU5HVEg7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBbW0FkZERlbGVnYXRvclR4XV0uXG4gICAgICovXG4gICAgdG9CdWZmZXIoKTpCdWZmZXIge1xuICAgICAgICBjb25zdCBzdXBlcmJ1ZmY6QnVmZmVyID0gc3VwZXIudG9CdWZmZXIoKTtcbiAgICAgICAgbGV0IGJzaXplOm51bWJlciA9IHN1cGVyYnVmZi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG51bW91dHM6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICBudW1vdXRzLndyaXRlVUludDMyQkUodGhpcy5zdGFrZU91dHMubGVuZ3RoLCAwKTtcbiAgICAgICAgbGV0IGJhcnI6QXJyYXk8QnVmZmVyPiA9IFtzdXBlci50b0J1ZmZlcigpLCBudW1vdXRzXTtcbiAgICAgICAgYnNpemUgKz0gbnVtb3V0cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuc3Rha2VPdXRzID0gdGhpcy5zdGFrZU91dHMuc29ydChUcmFuc2ZlcmFibGVPdXRwdXQuY29tcGFyYXRvcigpKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3Rha2VPdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3V0OkJ1ZmZlciA9IHRoaXMuc3Rha2VPdXRzW2ldLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICBiYXJyLnB1c2gob3V0KTtcbiAgICAgICAgICAgIGJzaXplICs9IG91dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvOkJ1ZmZlciA9IHRoaXMucmV3YXJkT3duZXJzLnRvQnVmZmVyKCk7XG4gICAgICAgIGJhcnIucHVzaChybyk7XG4gICAgICAgIGJzaXplICs9IHJvLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmFyciwgYnNpemUpO1xuICAgIH1cblxuICAgIGNsb25lKCk6dGhpcyB7XG4gICAgICAgIGxldCBuZXdiYXNlOkFkZERlbGVnYXRvclR4ID0gbmV3IEFkZERlbGVnYXRvclR4KCk7XG4gICAgICAgIG5ld2Jhc2UuZnJvbUJ1ZmZlcih0aGlzLnRvQnVmZmVyKCkpO1xuICAgICAgICByZXR1cm4gbmV3YmFzZSBhcyB0aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZSguLi5hcmdzOmFueVtdKTp0aGlzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGREZWxlZ2F0b3JUeCguLi5hcmdzKSBhcyB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBBZGREZWxlZ2F0b3JUeCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JraWQgT3B0aW9uYWwuIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIE9wdGlvbmFsLiBCbG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICogQHBhcmFtIGlucyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXNcbiAgICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbC4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIG5vZGVJRCBPcHRpb25hbC4gVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdGFydHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdG9wcyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsgKGFuZCBzdGFrZWQgQVZBWCBpcyByZXR1cm5lZCkuXG4gICAgICogQHBhcmFtIHN0YWtlQW1vdW50IE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIG5BVkFYIHRoZSB2YWxpZGF0b3IgaXMgc3Rha2luZy5cbiAgICAgKiBAcGFyYW0gc3Rha2VPdXRzIE9wdGlvbmFsLiBUaGUgb3V0cHV0cyB1c2VkIGluIHBheWluZyB0aGUgc3Rha2UuXG4gICAgICogQHBhcmFtIHJld2FyZE93bmVycyBPcHRpb25hbC4gVGhlIFtbUGFyc2VhYmxlT3V0cHV0XV0gY29udGFpbmluZyBhIFtbU0VDUE93bmVyT3V0cHV0XV0gZm9yIHRoZSByZXdhcmRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBuZXR3b3JraWQ6bnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCwgXG4gICAgICAgIGJsb2NrY2hhaW5pZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDE2KSwgXG4gICAgICAgIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB1bmRlZmluZWQsIFxuICAgICAgICBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICAgIG5vZGVJRDpCdWZmZXIgPSB1bmRlZmluZWQsIFxuICAgICAgICBzdGFydFRpbWU6Qk4gPSB1bmRlZmluZWQsIFxuICAgICAgICBlbmRUaW1lOkJOID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGFrZUFtb3VudDpCTiA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3Rha2VPdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSB1bmRlZmluZWQsXG4gICAgICAgIHJld2FyZE93bmVyczpQYXJzZWFibGVPdXRwdXQgPSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgICAgc3VwZXIobmV0d29ya2lkLCBibG9ja2NoYWluaWQsIG91dHMsIGlucywgbWVtbywgbm9kZUlELCBzdGFydFRpbWUsIGVuZFRpbWUsIHN0YWtlQW1vdW50KTtcbiAgICAgICAgaWYodHlwZW9mIHN0YWtlT3V0cyAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMuc3Rha2VPdXRzID0gc3Rha2VPdXRzXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXdhcmRPd25lcnMgPSByZXdhcmRPd25lcnM7XG4gICAgfVxuICB9XG5cbmV4cG9ydCBjbGFzcyBBZGRWYWxpZGF0b3JUeCBleHRlbmRzIEFkZERlbGVnYXRvclR4IHtcbiAgICBwcm90ZWN0ZWQgX3R5cGVOYW1lID0gXCJBZGRWYWxpZGF0b3JUeFwiO1xuICAgIHByb3RlY3RlZCBfdHlwZUlEID0gUGxhdGZvcm1WTUNvbnN0YW50cy5BRERWQUxJREFUT1JUWDtcblxuICAgIHNlcmlhbGl6ZShlbmNvZGluZzpTZXJpYWxpemVkRW5jb2RpbmcgPSBcImhleFwiKTpvYmplY3Qge1xuICAgICAgICBsZXQgZmllbGRzOm9iamVjdCA9IHN1cGVyLnNlcmlhbGl6ZShlbmNvZGluZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBcImRlbGVnYXRpb25GZWVcIjogc2VyaWFsaXplci5lbmNvZGVyKHRoaXMuZ2V0RGVsZWdhdGlvbkZlZUJ1ZmZlcigpLCBlbmNvZGluZywgXCJCdWZmZXJcIiwgXCJkZWNpbWFsU3RyaW5nXCIsIDQpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlc2VyaWFsaXplKGZpZWxkczpvYmplY3QsIGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpIHtcbiAgICAgICAgc3VwZXIuZGVzZXJpYWxpemUoZmllbGRzLCBlbmNvZGluZyk7XG4gICAgICAgIGxldCBkYnVmZjpCdWZmZXIgPSBzZXJpYWxpemVyLmRlY29kZXIoZmllbGRzW1wiZGVsZWdhdGlvbkZlZVwiXSwgZW5jb2RpbmcsIFwiZGVjaW1hbFN0cmluZ1wiLCBcIkJ1ZmZlclwiLCA0KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0aW9uRmVlID0gZGJ1ZmYucmVhZFVJbnQzMkJFKDApIC8gQWRkVmFsaWRhdG9yVHguZGVsZWdhdG9yTXVsdGlwbGllcjtcbiAgICB9XG4gIFxuXG5cbiAgICBwcm90ZWN0ZWQgZGVsZWdhdGlvbkZlZTpudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgc3RhdGljIGRlbGVnYXRvck11bHRpcGxpZXI6bnVtYmVyID0gMTAwMDA7XG5cbiAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBbW0FkZFZhbGlkYXRvclR4XV1cbiAgICAgICAqL1xuICAgIGdldFR4VHlwZSA9ICgpOm51bWJlciA9PiB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVJRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWxlZ2F0aW9uIGZlZSAocmVwcmVzZW50cyBhIHBlcmNlbnRhZ2UgZnJvbSAwIHRvIDEwMCk7XG4gICAgICovXG4gICAgZ2V0RGVsZWdhdGlvbkZlZSgpOm51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRpb25GZWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZWxlZ2F0aW9uIGZlZSBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgICAqL1xuICAgIGdldERlbGVnYXRpb25GZWVCdWZmZXIoKTpCdWZmZXIge1xuICAgICAgICBsZXQgZEJ1ZmY6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICBsZXQgYnVmZm51bTpudW1iZXIgPSBwYXJzZUZsb2F0KHRoaXMuZGVsZWdhdGlvbkZlZS50b0ZpeGVkKDQpKSAqIEFkZFZhbGlkYXRvclR4LmRlbGVnYXRvck11bHRpcGxpZXI7XG4gICAgICAgIGRCdWZmLndyaXRlVUludDMyQkUoYnVmZm51bSwgMCk7XG4gICAgICAgIHJldHVybiBkQnVmZjtcbiAgICB9XG5cbiAgICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgICAgIG9mZnNldCA9IHN1cGVyLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIGxldCBkYnVmZjpCdWZmZXIgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGlvbkZlZSA9IGRidWZmLnJlYWRVSW50MzJCRSgwKSAvIEFkZFZhbGlkYXRvclR4LmRlbGVnYXRvck11bHRpcGxpZXI7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgdG9CdWZmZXIoKTpCdWZmZXIge1xuICAgICAgICBsZXQgc3VwZXJCdWZmOkJ1ZmZlciA9IHN1cGVyLnRvQnVmZmVyKCk7XG4gICAgICAgIGxldCBmZWVCdWZmOkJ1ZmZlciA9IHRoaXMuZ2V0RGVsZWdhdGlvbkZlZUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbc3VwZXJCdWZmLCBmZWVCdWZmXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIHVuc2lnbmVkIEFkZFZhbGlkYXRvclR4IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtpZCBPcHRpb25hbC4gTmV0d29ya2lkLCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgICAqIEBwYXJhbSBibG9ja2NoYWluaWQgT3B0aW9uYWwuIEJsb2NrY2hhaW5pZCwgZGVmYXVsdCBCdWZmZXIuYWxsb2MoMzIsIDE2KVxuICAgICAqIEBwYXJhbSBvdXRzIE9wdGlvbmFsLiBBcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXNcbiAgICAgKiBAcGFyYW0gaW5zIE9wdGlvbmFsLiBBcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVJbnB1dF1dc1xuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIG1lbW8gZmllbGRcbiAgICAgKiBAcGFyYW0gbm9kZUlEIE9wdGlvbmFsLiBUaGUgbm9kZSBJRCBvZiB0aGUgdmFsaWRhdG9yIGJlaW5nIGFkZGVkLlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgT3B0aW9uYWwuIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0YXJ0cyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsuXG4gICAgICogQHBhcmFtIGVuZFRpbWUgT3B0aW9uYWwuIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0b3BzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yayAoYW5kIHN0YWtlZCBBVkFYIGlzIHJldHVybmVkKS5cbiAgICAgKiBAcGFyYW0gc3Rha2VBbW91bnQgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgbkFWQVggdGhlIHZhbGlkYXRvciBpcyBzdGFraW5nLlxuICAgICAqIEBwYXJhbSBzdGFrZU91dHMgT3B0aW9uYWwuIFRoZSBvdXRwdXRzIHVzZWQgaW4gcGF5aW5nIHRoZSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gcmV3YXJkT3duZXJzIE9wdGlvbmFsLiBUaGUgW1tQYXJzZWFibGVPdXRwdXRdXSBjb250YWluaW5nIHRoZSBbW1NFQ1BPd25lck91dHB1dF1dIGZvciB0aGUgcmV3YXJkcy5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGlvbkZlZSBPcHRpb25hbC4gVGhlIHBlcmNlbnQgZmVlIHRoaXMgdmFsaWRhdG9yIGNoYXJnZXMgd2hlbiBvdGhlcnMgZGVsZWdhdGUgc3Rha2UgdG8gdGhlbS4gXG4gICAgICogVXAgdG8gNCBkZWNpbWFsIHBsYWNlcyBhbGxvd2VkOyBhZGRpdGlvbmFsIGRlY2ltYWwgcGxhY2VzIGFyZSBpZ25vcmVkLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLCBpbmNsdXNpdmUuIFxuICAgICAqIEZvciBleGFtcGxlLCBpZiBkZWxlZ2F0aW9uRmVlUmF0ZSBpcyAxLjIzNDUgYW5kIHNvbWVvbmUgZGVsZWdhdGVzIHRvIHRoaXMgdmFsaWRhdG9yLCB0aGVuIHdoZW4gdGhlIGRlbGVnYXRpb24gXG4gICAgICogcGVyaW9kIGlzIG92ZXIsIDEuMjM0NSUgb2YgdGhlIHJld2FyZCBnb2VzIHRvIHRoZSB2YWxpZGF0b3IgYW5kIHRoZSByZXN0IGdvZXMgdG8gdGhlIGRlbGVnYXRvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgbmV0d29ya2lkOm51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsIFxuICAgICAgICBibG9ja2NoYWluaWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyLCAxNiksIFxuICAgICAgICBvdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSB1bmRlZmluZWQsIFxuICAgICAgICBpbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+ID0gdW5kZWZpbmVkLCBcbiAgICAgICAgbWVtbzpCdWZmZXIgPSB1bmRlZmluZWQsIFxuICAgICAgICBub2RlSUQ6QnVmZmVyID0gdW5kZWZpbmVkLCBcbiAgICAgICAgc3RhcnRUaW1lOkJOID0gdW5kZWZpbmVkLCBcbiAgICAgICAgZW5kVGltZTpCTiA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3Rha2VBbW91bnQ6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YWtlT3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkLFxuICAgICAgICByZXdhcmRPd25lcnM6UGFyc2VhYmxlT3V0cHV0ID0gdW5kZWZpbmVkLFxuICAgICAgICBkZWxlZ2F0aW9uRmVlOm51bWJlciA9IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIG5ldHdvcmtpZCwgXG4gICAgICAgICAgICBibG9ja2NoYWluaWQsIFxuICAgICAgICAgICAgb3V0cywgXG4gICAgICAgICAgICBpbnMsIFxuICAgICAgICAgICAgbWVtbywgXG4gICAgICAgICAgICBub2RlSUQsIFxuICAgICAgICAgICAgc3RhcnRUaW1lLCBcbiAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICBzdGFrZUFtb3VudCxcbiAgICAgICAgICAgIHN0YWtlT3V0cyxcbiAgICAgICAgICAgIHJld2FyZE93bmVyc1xuICAgICAgICApO1xuICAgICAgICBpZih0eXBlb2YgZGVsZWdhdGlvbkZlZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYoZGVsZWdhdGlvbkZlZSA+PSAwICYmIGRlbGVnYXRpb25GZWUgPD0gMTAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0aW9uRmVlID0gcGFyc2VGbG9hdChkZWxlZ2F0aW9uRmVlLnRvRml4ZWQoNCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRWYWxpZGF0b3JUeC5jb25zdHJ1Y3RvciAtLSBkZWxlZ2F0aW9uRmVlIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDAgYW5kIDEwMCwgaW5jbHVzaXZlbHkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSJdfQ==